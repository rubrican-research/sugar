unit sugar.ulid;

{Generated by ChatGPT - 11/Aug/2025}

{
	A ULID (Universally Unique Lexicographically Sortable Identifier)
	is an alternative to UUID/GUID that’s designed to be:

	Globally unique — like a UUID, you can generate it
	anywhere without coordination and collisions are
	astronomically unlikely.

	Lexicographically sortable — the generated IDs are
	ordered by time, so if you sort them as strings,
	you get chronological order.

	Compact & readable — it’s a 26-character string using
	Crockford’s Base32 alphabet (digits + uppercase
	letters without ambiguous ones like I, L, O, U).
}

{$mode ObjFPC}{$H+}

interface

function newULID: string;

implementation

uses
    SysUtils, DateUtils;

const
    // Crockford's Base32 without I, L, O, U
    ULID_ALPHABET = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';

type
    TULIDBytes = array[0..15] of byte; // 128 bits

procedure EncodeBase32(const Data: TULIDBytes; out ULIDStr: string);
var
    Bits: QWord;
    BitCount, i: integer;
    Value: byte;
    Output: array[0..25] of char;
    DataIndex: integer;
begin
    FillChar(Output, SizeOf(Output), 0);
    Bits := 0;
    BitCount := 0;
    DataIndex := 0;

    for i := 0 to High(Output) do
    begin
        while (BitCount < 5) and (DataIndex < Length(Data)) do
        begin
            Bits := (Bits shl 8) or Data[DataIndex];
            Inc(DataIndex);
            Inc(BitCount, 8);
        end;

        Value := (Bits shr (BitCount - 5)) and $1F;
        BitCount := BitCount - 5;
        Output[i] := ULID_ALPHABET[Value + 1];
    end;

    SetString(ULIDStr, PChar(@Output[0]), Length(Output));
end;

function GetUnixTimeMs: QWord;
begin
    Result := QWord(MilliSecondsBetween(UnixEpoch, Now) * -1); // UnixEpoch is 1970-01-01
end;

procedure RandomBytes(var Buf; Count: integer);
var
    p: pbyte;
    i: integer;
begin
    p := @Buf;
    for i := 0 to Count - 1 do
        p[i] := Random(256);
end;

function newULID: string;
var
    ULIDData: TULIDBytes;
    TimeMs: QWord;
    i: integer;
begin
    // 1) Time part (48 bits)
    TimeMs := GetUnixTimeMs;
    for i := 0 to 5 do
        ULIDData[i] := (TimeMs shr ((5 - i) * 8)) and $FF;

    // 2) Random part (80 bits)
    Randomize;
    RandomBytes(ULIDData[6], 10);

    // 3) Encode to 26-char Crockford Base32
    EncodeBase32(ULIDData, Result);
end;

end.
