unit sugar.gender;
{***********************************************************************************}
{* This unit was first generated by Claude 3.7 Sonnet on April 17, 2025            *}
{* It has been edited to add prononous                                             *}


{$mode objfpc}{$H+}

interface
uses
    sysutils, classes, fgl, sugar.maps, fpjson;

type

    NGenderType = (
        genderUnknown        ,
        genderPreferNotToSay ,
        genderFeminine       ,
        genderMasculine      ,
        genderNonBinary      ,
        genderCustom
    );

    TGenderValues = array[NGenderType] of TStringArray;

	{ TGender }

    TGender =  class
        genderType: NGenderType;
        name: shortstring;
        titles  : TStringList;     // sorted
        titleSymbols: TStringList; // sorted
        pronouns: TStringList;     // sorted
        constructor Create(_g: NGenderType; _name: shortstring; _pronouns: TStringArray; _titles: TStringArray);
        destructor Destroy; override;

        function asJSONObj: TJSONObject;
        function asJSON: string;

    end;

	{ TGenderList }

    TGenderList = class(specialize TFPGMapObject<string, TGender>)
    public
        constructor Create(AFreeObjects: Boolean = true);
        destructor Destroy; override;
    end;

    TArrayGenderTypeList = array[NGenderType] of TGenderList;


    { TGenderDef }

    TGenderDef = class
    protected
        myGenders : TGenderList;
        gtypeIndex: TArrayGenderTypeList; // Index of Gender items by NGenderType
    public

        constructor Create;
        destructor Destroy; override;

        function genderObj(_name: string): TGender;
        function genderExists(_name: string) : boolean;

        procedure registerGender(_gt: NGenderType; _name: shortstring; _pronouns: TStringArray; _titles: TStringArray); overload;
        procedure registerGender(_gt: NGenderType; _names: TStringArray); overload;

        procedure registerPronoun(_name: string; _pronoun: shortstring); overload;
        procedure registerPronouns(_name: string; _pronouns: TStringArray); overload;

        procedure registerTitle(_name: string; _title: shortstring); overload;
        procedure registerTitles(_name: string; _titles: TStringArray); overload;

        function genderNames: TStringArray;
        function genderType(_name: string): NGenderType;

        function genderNames(_gt: NGenderType): TStringArray;
        function genderTitles(_gt: NGenderType): TStringArray;
        function genderPronouns(_gt: NGenderType): TStringArray;

        function removeGender(_name: string): boolean;
    end;

    TProcGenderDef = function: TGenderDef;

    // Returns an instance of managed TGenderDef associated with
    // language. This is useful because each lanugage has their own
    // distinct list of gender terms.
    function getGenderDef(_isocode: shortstring; _factory: TProcGenderDef): TGenderDef;

    {Bare minimum gender definitions }
    function initGenderDefEN: TGenderDef;  // English
    function initGenderDefDE: TGenderDef;  // German
    function initGenderDefFR: TGenderDef;  // French
    function initGenderDefES: TGenderDef;  // Spanish
    function initGenderDefIT: TGenderDef;  // Italian
    function initGenderDefNL: TGenderDef;  // Dutch
    function initGenderDefUK: TGenderDef;  // Ukranian
    function initGenderDefHE: TGenderDef;  // Hebrew
    function initGenderDefRU: TGenderDef;  // Russian
    function initGenderDefAR: TGenderDef;  // Arabic
    function initGenderDefKO: TGenderDef;  // Korean
    function initGenderDefJA: TGenderDef;  // Japanese
    function initGenderDefZH: TGenderDef;  // Chinese


    {helper functions to intantiate singletons of gender definitions}
    {applications can instantiate their own gender}
    function gendersEN: TGenderDef;
    function gendersDE: TGenderDef;
    function gendersFR: TGenderDef;
    function gendersES: TGenderDef;
    function gendersIT: TGenderDef;
    function gendersNL: TGenderDef;


implementation
uses
  sugar.languages;

type
    TGenderDefLangs = class(specialize TFPGMapObject<string, TGenderDef>)

	end;

var
    myGenderDefLangs : TGenderDefLangs;

function initGenderDefEN: TGenderDef;
var
	g: NGenderType;
begin
    Result := TGenderDef.Create;
    with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, 'Prefer not to say',['They/Them'], []);

        registerGender(genderFeminine, 'Woman', ['She/Her'], ['Miss', 'Mrs', 'Ms']);
        registerGender(genderFeminine, 'Female', ['She/Her'], ['Miss', 'Mrs', 'Ms']);

        registerGender(genderMasculine, 'Man', ['He/Him'], ['Mr']);
        registerGender(genderMasculine, 'Male', ['He/Him'], ['Mr']);

        registerGender(genderNonBinary, 'Non-binary', ['They/Them'], ['Mx.']);
        registerGender(genderCustom, 'Custom', [],[]);
	end;
end;

function initGenderDefDE: TGenderDef;
begin
    Result := TGenderDef.Create;
    with Result do begin
       registerGender(genderUnknown, '', [], []);
       registerGender(genderPreferNotToSay, 'Möchte nicht angeben', ['Sie/Ihnen'], []);

       registerGender(genderFeminine, 'Frau', ['Sie/Ihr'], ['Frl.', 'Fr.']);
       registerGender(genderFeminine, 'Weiblich', ['Sie/Ihr'], ['Frl.', 'Fr.']);

       registerGender(genderMasculine, 'Mann', ['Er/Ihm'], ['Hr.']);
       registerGender(genderMasculine, 'Männlich', ['Er/Ihm'], ['Hr.']);

       registerGender(genderNonBinary, 'Nichtbinär', ['Sie/Ihnen'], ['Mx.']);
       registerGender(genderCustom, 'Benutzerdefiniert', [], []);
    end;
end;

function initGenderDefFR: TGenderDef;
var
	g: NGenderType;
begin
    Result := TGenderDef.Create;
    with Result do begin
       registerGender(genderUnknown, '', [], []);
       registerGender(genderPreferNotToSay, 'Préfère ne pas préciser', ['Iel/Ellui'], []);

       registerGender(genderFeminine, 'Femme', ['Elle/La'], ['Mlle', 'Mme']);
       registerGender(genderFeminine, 'Féminin', ['Elle/La'], ['Mlle', 'Mme']);

       registerGender(genderMasculine, 'Homme', ['Il/Lui'], ['M.']);
       registerGender(genderMasculine, 'Masculin', ['Il/Lui'], ['M.']);

       registerGender(genderNonBinary, 'Non-binaire', ['Iel/Ellui'], ['Mx']);
       registerGender(genderCustom, 'Personnalisé', [], []);
    end;
end;

function initGenderDefES: TGenderDef;
begin
    Result := TGenderDef.Create;
    with Result do begin
       registerGender(genderUnknown, '', [], []);
       registerGender(genderPreferNotToSay, 'Prefiero no decirlo', ['Elle/Le'], []);

       registerGender(genderFeminine, 'Mujer', ['Ella/La'], ['Srta.', 'Sra.']);
       registerGender(genderFeminine, 'Femenino', ['Ella/La'], ['Srta.', 'Sra.']);

       registerGender(genderMasculine, 'Hombre', ['Él/Lo'], ['Sr.']);
       registerGender(genderMasculine, 'Masculino', ['Él/Lo'], ['Sr.']);

       registerGender(genderNonBinary, 'No binario', ['Elle/Le'], ['Mx']);
       registerGender(genderCustom, 'Personalizado', [], []);
    end;
end;

function initGenderDefIT: TGenderDef;
begin
    Result := TGenderDef.Create;
    with Result do begin
       registerGender(genderUnknown, '', [], []);
       registerGender(genderPreferNotToSay, 'Preferisco non dirlo', ['Loro/Le'], []);

       registerGender(genderFeminine, 'Donna', ['Lei/La'], ['Sig.na', 'Sig.ra']);
       registerGender(genderFeminine, 'Femminile', ['Lei/La'], ['Sig.na', 'Sig.ra']);

       registerGender(genderMasculine, 'Uomo', ['Lui/Lo'], ['Sig.']);
       registerGender(genderMasculine, 'Maschile', ['Lui/Lo'], ['Sig.']);

       registerGender(genderNonBinary, 'Non binario', ['Loro/Le'], ['Mx']);
       registerGender(genderCustom, 'Personalizzato', [], []);
    end;
end;

function initGenderDefNL: TGenderDef;
begin
    Result := TGenderDef.Create;
    with Result do begin
       registerGender(genderUnknown, '', [], []);
       registerGender(genderPreferNotToSay, 'Liever niet zeggen', ['Hen/Hun'], []);

       registerGender(genderFeminine, 'Vrouw', ['Zij/Haar'], ['Mej.', 'Mevr.']);
       registerGender(genderFeminine, 'Vrouwelijk', ['Zij/Haar'], ['Mej.', 'Mevr.']);

       registerGender(genderMasculine, 'Man', ['Hij/Hem'], ['Dhr.']);
       registerGender(genderMasculine, 'Mannelijk', ['Hij/Hem'], ['Dhr.']);

       registerGender(genderNonBinary, 'Non-binair', ['Hen/Hun'], ['Mx']);
       registerGender(genderCustom, 'Aangepast', [], []);
    end;
end;

function initGenderDefZH: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, '不愿透露', ['他们/她们'], []);

        registerGender(genderFeminine, '女性', ['她/她的'], ['小姐', '女士']);
        registerGender(genderFeminine, '女', ['她/她的'], ['小姐', '女士']);

        registerGender(genderMasculine, '男性', ['他/他的'], ['先生']);
        registerGender(genderMasculine, '男', ['他/他的'], ['先生']);

        registerGender(genderNonBinary, '非二元性别', ['他们/她们'], ['Mx']);
        registerGender(genderCustom, '自定义', [], []);
     end;
end;

function initGenderDefJA: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, '回答したくない', ['彼ら/彼らの'], []);

        registerGender(genderFeminine, '女性', ['彼女/彼女の'], ['さん', '様']);
        registerGender(genderFeminine, '女', ['彼女/彼女の'], ['さん', '様']);

        registerGender(genderMasculine, '男性', ['彼/彼の'], ['さん', '様']);
        registerGender(genderMasculine, '男', ['彼/彼の'], ['さん', '様']);

        registerGender(genderNonBinary, 'ノンバイナリー', ['彼ら/彼らの'], ['さん']);
        registerGender(genderCustom, 'カスタム', [], []);
     end;
end;

function initGenderDefKO: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, '밝히지 않음', ['그들/그들의'], []);

        registerGender(genderFeminine, '여성', ['그녀/그녀의'], ['양', '씨']);
        registerGender(genderFeminine, '여', ['그녀/그녀의'], ['양', '씨']);

        registerGender(genderMasculine, '남성', ['그/그의'], ['씨']);
        registerGender(genderMasculine, '남', ['그/그의'], ['씨']);

        registerGender(genderNonBinary, '논바이너리', ['그들/그들의'], ['씨']);
        registerGender(genderCustom, '사용자 정의', [], []);
     end;
end;

function initGenderDefAR: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, 'أفضل عدم الذكر', ['هم/لهم'], []);

        registerGender(genderFeminine, 'امرأة', ['هي/لها'], ['آنسة', 'سيدة']);
        registerGender(genderFeminine, 'أنثى', ['هي/لها'], ['آنسة', 'سيدة']);

        registerGender(genderMasculine, 'رجل', ['هو/له'], ['سيد']);
        registerGender(genderMasculine, 'ذكر', ['هو/له'], ['سيد']);

        registerGender(genderNonBinary, 'غير ثنائي', ['هم/لهم'], ['Mx']);
        registerGender(genderCustom, 'مخصص', [], []);
     end;
end;

function initGenderDefRU: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, 'Предпочитаю не указывать', ['Они/Их'], []);

        registerGender(genderFeminine, 'Женщина', ['Она/Её'], ['г-жа']);
        registerGender(genderFeminine, 'Женский', ['Она/Её'], ['г-жа']);

        registerGender(genderMasculine, 'Мужчина', ['Он/Его'], ['г-н']);
        registerGender(genderMasculine, 'Мужской', ['Он/Его'], ['г-н']);

        registerGender(genderNonBinary, 'Небинарный', ['Они/Их'], ['Mx']);
        registerGender(genderCustom, 'Другое', [], []);
     end;
end;

function initGenderDefHE: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, 'מעדיף/ה לא לציין', ['הם/הן'], []);

        registerGender(genderFeminine, 'אישה', ['היא/שלה'], ['גב׳']);
        registerGender(genderFeminine, 'נקבה', ['היא/שלה'], ['גב׳']);

        registerGender(genderMasculine, 'גבר', ['הוא/שלו'], ['מר']);
        registerGender(genderMasculine, 'זכר', ['הוא/שלו'], ['מר']);

        registerGender(genderNonBinary, 'א-בינארי', ['הם/הן'], ['Mx']);
        registerGender(genderCustom, 'מותאם אישית', [], []);
     end;
end;

function initGenderDefUK: TGenderDef;
begin
     Result := TGenderDef.Create;
     with Result do begin
        registerGender(genderUnknown, '', [], []);
        registerGender(genderPreferNotToSay, 'Воліють не вказувати', ['Вони/Їх'], []);

        registerGender(genderFeminine, 'Жінка', ['Вона/Її'], ['п-ні']);
        registerGender(genderFeminine, 'Жіноча', ['Вона/Її'], ['п-ні']);

        registerGender(genderMasculine, 'Чоловік', ['Він/Його'], ['п-н']);
        registerGender(genderMasculine, 'Чоловіча', ['Він/Його'], ['п-н']);

        registerGender(genderNonBinary, 'Небінарний', ['Вони/Їх'], ['Mx']);
        registerGender(genderCustom, 'Власний варіант', [], []);
     end;
end;

function getGenderDef(_isocode: shortstring; _factory: TProcGenderDef): TGenderDef;
var
	i: Integer;
begin
    if not myGenderDefLangs.Find(_isocode,  i) then begin
        if assigned(_factory) then begin
            Result := _factory();
            myGenderDefLangs.Add(_isocode, Result);
		end
        else
            raise Exception.Create('getGenderDefObj:: Factory method is not assigned');
	end
    else
        Result := myGenderDefLangs.Data[i];
end;


function gendersEN: TGenderDef;
begin
    result := getGenderDef(ISO693_English, @initGenderDefEN);
end;

function gendersDE: TGenderDef;
begin
    result := getGenderDef(ISO693_German, @initGenderDefDE);
end;

function gendersFR: TGenderDef;
begin
    result := getGenderDef(ISO693_French, @initGenderDefFR);
end;

function gendersES: TGenderDef;
begin
    result := getGenderDef(ISO693_Spanish, @initGenderDefES);
end;

function gendersIT: TGenderDef;
begin
    result := getGenderDef(ISO693_Italian, @initGenderDefIT);
end;

function gendersNL: TGenderDef;
begin
    result := getGenderDef(ISO693_Dutch, @initGenderDefNL);
end;

{ TGender }

constructor TGender.Create(_g: NGenderType; _name: shortstring;
	_pronouns: TStringArray; _titles: TStringArray);
var
	_s: String;
begin
    inherited Create;
    genderType := _g;
    name       := _name;

    pronouns   := TStringList.Create;
    pronouns.sorted := true;
    for _s in _pronouns do pronouns.Add(_s);

    titles     := TStringList.Create;
    titles.sorted := true;
    for _s in _titles do titles.Add(_s);
end;

destructor TGender.Destroy;
begin
    titles.Free;
    pronouns.Free;
	inherited Destroy;
end;

function TGender.asJSONObj: TJSONObject;
begin
    Result := TJSONObject.Create;
end;

function TGender.asJSON: string;
begin
    with asJSONObj do begin
        Result := FormatJSON();
        Free;
	end;
end;

{ TGenderList }

constructor TGenderList.Create(AFreeObjects: Boolean);
begin
    inherited Create(AFreeObjects);
end;

destructor TGenderList.Destroy;
begin
	inherited Destroy;
end;

{ TGenderDef }

constructor TGenderDef.Create;
var
	g: NGenderType;
begin
    inherited Create;
    myGenders := TGenderList.Create(true);
    myGenders.Sorted := true;
    for g in NGenderType do begin
        gtypeIndex[g] := TGenderList.Create(false); // Only stores references
        gtypeIndex[g].sorted := true;
	end;
end;

destructor TGenderDef.Destroy;
var
	g: NGenderType;
begin
    for g in NGenderType do
        gtypeIndex[g].Free;
    myGenders.Free;
	inherited Destroy;
end;

procedure TGenderDef.registerGender(_gt: NGenderType; _name: shortstring;
	_pronouns: TStringArray; _titles: TStringArray);
var
	_i: Integer;
	_gender: TGender;
begin
    if myGenders.Find(_name, _i) then exit;

    _gender := TGender.Create(_gt, _name, _pronouns, _titles);
    myGenders.Add(_name, _gender);

    if not gtypeIndex[_gt].find(_name, _i) then
        gtypeIndex[_gt].Add(_name, _gender);
end;

procedure TGenderDef.registerGender(_gt: NGenderType; _names: TStringArray);
var
	_name: String;
begin
    for _name in _names do

        registerGender(_gt, _name, [], []);
end;

procedure TGenderDef.registerPronoun(_name: string; _pronoun: shortstring);
var
	_gender: TGender;
	_i: Integer;
begin
    _gender := genderObj(_name);
    if not assigned(_gender) then exit;

    if not _gender.pronouns.Find(_pronoun, _i) then
        _gender.pronouns.add(_pronoun);

end;

procedure TGenderDef.registerPronouns(_name: string; _pronouns: TStringArray);
var
	_p: String;
begin
    for _p in _pronouns do
         registerPronoun(_name, _p);
end;

procedure TGenderDef.registerTitle(_name: string; _title: shortstring);
var
	_gender: TGender;
	_i: Integer;
begin
    _gender := genderObj(_name);
    if not assigned(_gender) then exit;

    if not _gender.titles.Find(_title, _i) then
        _gender.titles.add(_title);
end;

procedure TGenderDef.registerTitles(_name: string; _titles: TStringArray);
var
	_t: String;
begin
    for _t in _titles do
         registerTitle(_name, _t);
end;


function TGenderDef.genderNames: TStringArray;
var
	_size, i: Integer;
begin
    _size := myGenders.Count;
    Result := [];
    SetLength(Result, _size);
    for i := 0 to pred(_size) do begin
        Result[i] := myGenders.Keys[i];
	end;
end;

function TGenderDef.genderType(_name: string): NGenderType;
var
	_g: TGender;
begin
    _g := genderObj(_name);
    if assigned(_g) then
        Result :=_g.genderType
    else
        Result := genderUnknown;
end;

function TGenderDef.genderObj(_name: string): TGender;
var
	i: Integer;
begin
    Result := nil;
    if myGenders.find(_name, i) then
        Result := myGenders.Data[i];
end;

function TGenderDef.genderExists(_name: string): boolean;
begin
    Result := assigned(genderObj(_name));
end;

function TGenderDef.genderNames(_gt: NGenderType): TStringArray;
var
	_gl: TGenderList;
	i, _size: Integer;
begin
    _gl := gtypeIndex[_gt];
    _size := _gl.count;
    Result := [];
    SetLength(Result, _size);
    for i := 0 to pred(_gl.count) do begin
        Result[i] := _gl.Keys[i]; // Gender name
	end;
end;

function TGenderDef.genderTitles(_gt: NGenderType): TStringArray;
var
	_gl: TGenderList;
	_i, _count, _arrSize, _arrIndex: Integer;
	s: String;
begin
    Result := [];
    _gl := gtypeIndex[_gt];
    _count := _gl.count;
    _arrSize := 0;
    _arrIndex := 0;
    for _i := 0 to pred(_count) do begin
        inc(_arrSize,_gl.Data[_i].titles.Count);
        setLength(Result, _arrSize);
        for s in _gl.Data[_i].titles do begin
            Result[_arrIndex] := s; // Title
            inc(_arrIndex);
		end;
	end;
end;

function TGenderDef.genderPronouns(_gt: NGenderType): TStringArray;
var
	_gl: TGenderList;
	_i, _count, _arrSize, _arrIndex: Integer;
	s: String;
begin
    Result := [];
    _gl := gtypeIndex[_gt];
    _count := _gl.count;
    _arrSize := 0;
    _arrIndex := 0;
    for _i := 0 to pred(_count) do begin
        inc(_arrSize,_gl.Data[_i].pronouns.Count);
        setLength(Result, _arrSize);
        for s in _gl.Data[_i].pronouns do begin
            Result[_arrIndex] := s; // Pronoun
            inc(_arrIndex);
		end;
	end;
end;

function TGenderDef.removeGender(_name: string): boolean;
var
	_gender: TGender;
	_glist: TGenderList;
	_i: Integer;
begin
    Result := myGenders.Find(_name, _i);
    if Result then begin
        _gender := myGenders.Data[_i];
        _glist  := gtypeIndex[_gender.genderType];
        _glist.Delete(_glist.IndexOf(_name));
        myGenders.Delete(_i);
	end;
end;

initialization
    myGenderDefLangs := TGenderDefLangs.Create;
    myGenderDefLangs.sorted := true;

finalization
    myGenderDefLangs.Free;
end.
